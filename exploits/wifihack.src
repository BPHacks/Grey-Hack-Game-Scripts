// Tool used to automate 99% of the wifi hacking process.
// Replaces in-game tools "airmon", "iwlist", "aircrack", and "iwconfig".
// Unfortunately, we cannot yet automate packet capturing (see below for the long-winded version).

crypto = include_lib("/lib/crypto.so")
if not crypto then
	crypto = include_lib("crypto.so")
	if not crypto then exit("Unable to load crypto.so")
end if
host = get_shell.host_computer

// TODO: Will interface names ever differ from "eth0"?
//if params.len == 0 then exit(host.network_devices)
if params[0] == "-h" or params[0] == "--help" then exit("This application displays a list of wifi networks and then connects to the selected network if possible.")

//interface = params[0]
interface = "eth0"

if not crypto.airmon("start", interface) then exit("Unable to start monitor mode on " + interface)

print("Monitor mode started on " + interface)

networks = host.wifi_networks(interface)

if not networks then exit("Unable to get list of networks")

print("List of available networks:")
print("#              BSSID              ESSID Strength")
i = 1

for network in networks
	split = network.split(" ")
	bssid = split[0]
	strength = split[1]
	essid = split[2]
	
	print(i + ": <b>aireplay -b " + bssid + " -e " + essid + "</b> (" + strength + ")")
	i = i + 1
end for
networkToAttack = "0"
prompt = "Select a network to target, from 1 to " + networks.len + ":"
while networkToAttack.val >= networks.len or networkToAttack.val <= 0
	networkToAttack = user_input(prompt)
end while

// TODO: Automate actual packet capturing to replace "aireplay".
// Currently this is impossible due to the fact that you cannnot capture packets with the script system.
// Additionally, you cannot currently call programs that haven't been made scriptable themselves from scripts (e.g. shutdown, reboot).
// Furthermore, as far as I know, while you can call programs that have been made scriptable, you cannot interrupt them with CTRL-C and also regain control in the main script.
// Thus, there is no way to do this until at least one of the above issues is solved. :(
networkToAttack = networkToAttack.val - 1
user_input("Acknowledged. Use <b>aireplay</b> in another terminal window to capture 7,000-10,000 ACKs, close the other terminal window, then hit return on this window...")

// TODO: Figure out how to auto-kill aireplay
//procs = host.show_procs.split("\n")

//for proc in procs
//	split = proc.split(" ")
//	if split[4] == "aireplay" then
//		host.close_program(split[1].val)
//	end if
//end for

if not crypto.airmon("stop", interface) then exit("Unable to stop monitor mode on " + interface)

print("Monitor mode stopped on " + interface)

capFilePath = home_dir + "/file.cap"
capFile = host.File(capFilePath)

if not capFile then exit("Cap file doesn't exist. Did you run aireplay?")
if not capFile.has_permission("r") then exit("Can't open cap file for reading. Permission denied.")

key = crypto.aircrack(capFilePath)
print("Password found: [ <b>" + key + "</b> ]")
if not key then exit("Unable to get key. Make sure that you captured a sufficient number of ACKs (usually 7-10,000) or that you aireplayed the correct network.")
print("Got key. Connecting...")
split = networks[networkToAttack].split(" ")
bssid = split[0]
essid = split[2]
status = host.connect_wifi(interface, bssid, essid, key)
// TODO: iwconfig seems to check if this is a string, but it's an int.
// In the future we should probably check what it is before assuming, but for now, it works.
if status == 1 then 
	print("Connected successfully.")
else 
	print("Connection failed.")
end if

// TODO: Decide if I want to delete the cap file afterward (probably, given that it becomes useless after connecting).
// capFile.delete
